%% discuss techniques and refer to previous examples (message: it depends when what is feasible)
%\subsection{S1: Exclude Feature Combinations}
%% example: leonovo option compatibility matrix (even if not strictly enforced)
%% example: web configurators (Thinkpad)
%\subsection{S2: Orthogonal Implementation}
%\subsection{S3: Duplicate Implementations}
%\subsection{S4: Move Source Code}
%\subsection{S5: Preprocessors}
%\subsection{S6: Derivative Modules}
%\subsection{Overview on all Strategies}
%\subsection{When to Handle?}
%% spreadshirt example: fixing foreground+background colors for every order


\subsection{Motivation}

\begin{frame}{Handling/Implementing Feature Interactions}
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{note}{Assumptions}
			\begin{itemize}
				\item Interacting features have been already identified
				\item Interaction is a pairwise interaction (i.e., two features)
			\end{itemize}
		\end{note}
	\mynextcolumn
		\begin{definition}{Problem Description}
			\begin{itemize}
				\item Find a strategy to handle the interaction 
				\item Strategy does not introduce the optional-feature problem
			\end{itemize}
		\end{definition}
	\end{mycolumns}
\end{frame}

\begin{frame}[fragile]{Example: A Feature Interaction in our Graph Library}
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{exampletight}{}
			\centering
			\featureDiagram{
				Graph,concrete
				[Nodes,mandatory,abstract
					[Colored,optional,concrete]]
				[Edges,mandatory,abstract
					[Directed,optional,concrete]
					[Weighted,optional,concrete]]
				[Algorithms,mandatory,abstract,
					[ShortestPath,optional,concrete]]
			}
		\end{exampletight}
		\vspace{3mm}
		\begin{note}{}
			\begin{itemize}
				\item Domain view: $Weighted$ and $ShortestPath$ can be deliberately selected independent of each other.
				\item Implementation view: $ShortestPath$ requires $Weighted$ due to an implementation dependency (optional-feature problem!).
			\end{itemize}
		\end{note}
	\mynextcolumn
{\small
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	double weight;
	void setWeight(double w){ ... }
}
\end{codetight}	
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
		if(e1.weight > e2.weight) 
		... 
	}
}
\end{codetight}	
}
	\end{mycolumns}
\end{frame}

\begin{frame}{Handling/Implementing Feature Interactions: General Goals}
	\begin{note}{Question}
		What makes a good strategy to implement coordination code for feature interactions (while solving/avoiding the optional-feature problem)?
	\end{note}
	\pause
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{definition}{1. Variability}
			For every valid configuration (according to feature model), we can generate a product that implements this configuration.
		\end{definition}
		\pause
		\begin{definition}{2. Implementation effort}
			Should not require overwhelming implementation effort (would not be attractive in practice).
		\end{definition}
		\pause
	\mynextcolumn
		\begin{definition}{3. Binary size and performance}
			Should not increase binary size or decrease performance of products compared to an individual implementation of each product.
		\end{definition}
		\pause
		\begin{definition}{4. Code quality}
			Should not reduce code quality, which would make the product line harder to maintain. 
		\end{definition}
	\end{mycolumns}
\end{frame}

\subsection{S1: Adapt Feature Model}

\begin{frame}{S1 (a): Adapt Feature Model - Add Domain Dependency}
	\begin{definition}{Strategy}
		Declare implementation dependency as domain dependency in the feature model.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=1]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{exampletight}{}
			\centering
			\featureDiagram{
				Graph,concrete
				[Nodes,mandatory,abstract
					[Colored,optional,concrete]]
				[Edges,mandatory,abstract
					[Directed,optional,concrete]
					[Weighted,optional,concrete]]
				[Algorithms,mandatory,abstract,
					[ShortestPath,optional,concrete]]
			}

			$ShortestPath \pimplies Weighted$  
		\end{exampletight}
		\vspace{3mm}
		\begin{note}{}
			Same implementation as before, but we make implementation dependency explicit: $ShortestPath$ requires $Weighted$.
		\end{note}
	\mynextcolumn
{\small
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	double weight;
	void setWeight(double w){ ... }
}
\end{codetight}	
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
		if(e1.weight > e2.weight) 
		... 
	}
}
\end{codetight}	
}
	\end{mycolumns}
\end{frame}

\begin{frame}{S1 (b): Adapt Feature Model - Exclude Feature Combinations}
	\begin{definition}{Strategy}
		Declare problematic feature combinations as mutually exclusive in the feature model.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=2]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{exampletight}{}
			\centering
			\featureDiagram{
				Graph,concrete
				[Nodes,mandatory,abstract
					[Colored,optional,concrete]]
				[Edges,mandatory,abstract
					[Directed,optional,concrete]
					[Weighted,optional,concrete]]
				[Algorithms,mandatory,abstract,
					[ShortestPath,optional,concrete]]
			}

			$\pnot (ShortestPath \pand Weighted)$  
		\end{exampletight}
		\vspace{3mm}
		\begin{note}{}
			We may safely assume any uniform weight because $ShortestPath$ and $Weighted$ are mutually exclusive.
		\end{note}
	\mynextcolumn
\vspace{-3mm}
{\small
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	double weight;
	void setWeight(double w){ ... }
}
\end{codetight}	
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		@float w1 = 1.0;@
		@float w2 = 1.0;@
		...
		@if(w1 > w2)@
		... 
	}
}
\end{codetight}	
}
	\end{mycolumns}
\end{frame}

\subsection{S2: Orthogonal Implementation}

\begin{frame}{\myframetitle}
	\begin{definition}{Strategy}
		Orthogonal implementation with no dedicated coordination of interaction.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=3]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
		\begin{exampletight}{}
			\centering
			\featureDiagram{
				Graph,concrete
				[Nodes,mandatory,abstract
					[Colored,optional,concrete]]
				[Edges,mandatory,abstract
					[Directed,optional,concrete]
					[Weighted,optional,concrete]]
				[Algorithms,mandatory,abstract,
					[ShortestPath,optional,concrete]]
			}

			$\pnot (ShortestPath \pand Weighted)$  
		\end{exampletight}
		\vspace{3mm}
		\begin{note}{}
			Calculation of shortest path ignores weights but merely counts the number of edges on a path.
		\end{note}
	\mynextcolumn
{\small
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	double weight;
	void setWeight(double w){ ... }
}
\end{codetight}	
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		@// ignore weights@
		... 
	}
}
\end{codetight}	
}
	\end{mycolumns}
\end{frame}

\subsection{S3: Duplicate Implementations}

\begin{frame}{\myframetitle}
	\begin{definition}{Strategy}
		Multiple implementations of a feature, with and without coordination code.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=4]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
\begin{codetight}{layer: ShortestPath\_Unweighted}
refines class Graph {
	List shortestPath(Node a, Node b){
		...
		...
		// ignore weights
		... 
	}
}
\end{codetight}
		\begin{note}{}		
			Selected iff $ShortestPath \pand \pnot Weighted$. 
		\end{note}
	\mynextcolumn
\begin{codetight}{layer: ShortestPath\_Weighted}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
		if(e1.weight > e2.weight) 
		... 
	}
}
\end{codetight}	
		\begin{note}{}
			Selected iff $ShortestPath \pand Weighted$.
		\end{note}
	\end{mycolumns}
\end{frame}

\subsection{S4: Move Source Code}

\begin{frame}{\myframetitle}
	\begin{definition}{Strategy}
		Move all the coordination code to one of the features (or to a third one all interacting features depend on).
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=5]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	@double weight = 1.0;@
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	void setWeight(double w){ ... }
}
\end{codetight}	
	\mynextcolumn
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
		if(e1.weight > e2.weight) 
		... 
	}
}
\end{codetight}	
	\end{mycolumns}
\end{frame}

\subsection{S5: Conditional Compilation}

\begin{frame}{\myframetitle}
	\begin{definition}{Strategy}
		Coordination code is only executed if both features are selected.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=6]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
\begin{codetight}{layer: BasicGraph}
class Edge {
	private Node a, b;
	...
}
\end{codetight}	
\begin{codetight}{layer: Weighted}
refines class Edge {
	double weight;
	void setWeight(double w){ ... }
}
\end{codetight}	
	\mynextcolumn
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
@#ifdef WEIGHTED@		
		if(e1.weight > e2.weight) ...
@#endif@
		... 
	}
}
\end{codetight}	
	\end{mycolumns}
\end{frame}

\subsection{S6: Derivative Modules}

\begin{frame}{\myframetitle}
	\begin{definition}{Strategy}
		Create a dedicated module for code that coordinates features.
	\end{definition}
	\begin{notetight}{}
		\centering\includegraphics[width=0.7\linewidth,page=7]{interaction-handling}
	\end{notetight}
\end{frame}

\begin{frame}[fragile]{Example}
	\begin{mycolumns}[widths={50,50},animation=none]
\begin{codetight}{layer: ShortestPath}
refines class Graph {
	List shortestPath(Node a, Node b){
		Edge e1, e2;
		...
		if(isLonger(e1,e2)) 
		... 
	}
	boolean isLonger(Edge e1, Edge e2){
		return false;
	}
}
\end{codetight}	
	\mynextcolumn
\begin{codetight}{layer: ShortestPath\_Weighted}
refines class Graph {
	boolean isLonger(Edge e1, Edge e2){
		return e1.weight > e2.weight;
	}
}
\end{codetight}	
		\begin{note}{}	
			Selected iff $ShortestPath \pand Weighted$. 
		\end{note}
	\end{mycolumns}
\end{frame}

\subsection{Overview and Discussion}

\begin{frame}{Overview and Discussion}
	\centering\includegraphics[width=0.9\linewidth,page=8,trim=40 25 40 25,clip]{interaction-handling}
\end{frame}


